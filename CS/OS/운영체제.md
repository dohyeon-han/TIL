# 운영체제

## 운영체제의 역할
- 컴퓨터 시스템은 대게 하드웨어, 운영체제, 응용 프로그램, 사용자로 구분할 수 있다.
- 운영체제는 하드웨어와 응용 프로그램 간의 제어를 통해 사용자의 편의성을 향상(GUI, 음성인식, 터치스크린 등)시키고 리소스를 효과적으로 할당한다.

## 인터럽트
- 운영체제는 각 장치 컨트롤러마다 장치 드라이버가 있고 컨트롤러가 작동하게 일관된 인터페이스를 제공한다. 장치 컨트롤러는 CPU의 처리를 받기 위해 서로 경쟁한다.
- 장치 컨트롤러가 작업을 완료하면 인터럽트를 통해 장치 드라이버에게 상태 정보를 반환한다.

### 인터럽트 처리 순서
- 하드웨어는 CPU에 신호를 보내 인터럽트를 발생시킨다
- CPU는 하던 일을 중단하고 현재 상태를 저장한다.
- 인터럽트의 원인을 확인하고 인터럽트 벡터를 통해 인터럽트 서비스 루틴을 호출한다.
- 인터럽트를 처리한다.
- 인터럽트에서 복귀하여 중단된 작업을 처리한다.

### 인터럽트 벡터
- 인터럽트는 굉장히 빈번하게 실행된다. 이를 빠르게 처리하기 위해 필요한 인터럽트 루틴에 대한 주소를 미리 지정하여 처리한다.

### 인터럽트가 발생하는 이유
- 키보드 입력 같은 I/O 연산은 CPU의 속도에 비해 훨씬 느리다. 따라서 CPU를 효과적으로 사용하기 위해 인터럽트를 활용한다.

## 저장 구조
- CPU가 명령을 실행하려면 메모리에 프로그램이 적재되어야 한다. 범용 컴퓨터는 대부분의 프로그램을 메인 메모리에 적재한다. 이 메인 메모리는 주로 DRAM으로 만든다.
- RAM은 휘발성이므로 영구적으로 데이터를 보관할 수 없다. 또한 비싸기 때문에 많은 용량이 크지 않아 보조저장장치로 하드 디스크 드라이브(HDD)와 비휘발성 메모리(NVM)를 사용한다.
- DRAM과 디스크는 CPU에 비해 속도가 느리다. 이 격차를 줄이기 위해 캐시를 사용한다. 캐시는 휘발성 메모리로 자주 사용하는 데이터를 캐시에 복사해 두면 평균 메모리 접근 시간을 아낄 수 있다.

## 운영체제의 작동

### 멀티 프로그래밍과 멀티 태스킹
- 하나의 프로그램이 항상 CPU를 사용하고 있지는 않다. OS가 스케줄링을 통해 프로세스를 스케줄링하고 차례대로 CPU에 할당 받도록하여 CPU의 이용률을 높이는 것을 멀티 프로그래밍이라고 한다.
- 멀티 태스킹은 멀티 프로그래밍의 확장이다. 프로세스 간의 전환을 자주 발생시켜 CPU가 짧은 시간 동안 여러 프로세스를 번갈아가며 실행하는 것을 멀티 태스킹이라고 한다.

### 멀티 모드
- 운영체제는 잘못된 프로그램에 의해 다른 프로그램 혹은 운영체제가 잘못 실행되지 않도록 막아야 한다. 이를 위해 유저 모드, 커널 모드로 연산이 수행되는 위치를 나눈다.
- 트랩이나 인터럽트가 발생하면 커널 모드로 전환되고 운영체제가 컴퓨터의 제어를 얻게 된다. 
- 커널 모드에서만 수행되는 명령을 특권 명령이라고 하는데, 커널 모드로의 전환, I/O제어, 인터럽트 관리 등이 있다.

## 시스템 콜
- 하드웨어에 의한 인터럽트도 있지만 소프트웨어에 의한 인터럽트도 존재한다. 이를 trap이라한다.
    - Trap
        - Exception : 0나누기, 잘못된 기계어, 잘못된 메모리 접근
        - System call : 커널 모드로의 전환이 필요할 때
- 프로세스에서 커널 모드의 명령이 필요하면 시스템 콜을 호출한다. 작업을 모두 완료하면 OS는 커널 모드에서 유저 모드로 전환한다.

## 프로세스
- 프로세스는 메모리에 할당되어 실행되고 있는 프로그램을 의미한다.
 
### 프로세스 제어 블록
- 각 프로세스는 운영체제에서 프로세스 제어 블록(Process control block, PCB)에 의해 표현된다
- 프로세스 상태, 프로그램 카운터, 프로세스 번호 등 프로세스와 연관된 여러 정보를 담고 있다.

### 컨텍스트 스위치
- 인터럽트 혹은 시스템 콜이 실행되면 OS는 CPU에 실행되고 있는 작업을 뺏어 커널 루틴을 실행한다. 이 과정에서 PCB에 현재의 문맥을 저장하고 커널 작업이 끝나면 PCB를 통해 끊겼던 프로세스의 상태를 다시 복구하는데 이것을 컨텍스트 스위치라고한다.
- 이런 작업에는 진행되는 동안 시스템은 다른 작업을 할 수 없으므로 오버헤드가 발생한다.

### 프로세스 간 통신(Interprocesss Communicaiton)
- 기본적으로 프로세스는 다른 프로세스와 데이터를 공유하지 않는다. 따라서 다른 프로세스의 자원에 접근하려면 프로세스 간 통신(IPC)를 사용해야
    - Message passing : 커널을 통해 데이터를 교환한다. 커널 모드로 전환이 필요하기 때문에 컨택스트 스위칭이 일어나 오버헤드가 발생한다.
    - Shared memory : 두 프로세스 사이에 공유 영역을 설정해 데이터를 교환한다. 같은 영역을 사용하기 때문에 동기화가 필요하다.

## 스레드
- CPU 이용의 기본 단위이다. 
- 기존의 프로세스와 같은 일을 하는 프로세스를 생성하면 많은 오버헤드가 발생하기 때문에 스레드를 생성하는 것이 더 효율적이다.

### 장점
- 병렬로 스레드가 실행되므로 응답성이 뛰어나다.
- 같은 프로세스 내에서 다른 스레드와 자원들을 공유하기 때문에 컨텍스트 스위칭 없이 자원을 효과적을 사용할 수 있다.
- 멀티 스레드는 새 프로세스의 생성 없이 하나의 프로세스에서 여러가지 작업을 가능하게 한다.

### 단점
- 자원을 공유하기 때문에 동기화 문제가 발생한다.

### 스레드 풀
- 스레드를 새로 생성하는 것은 시간이 오래 걸린다. 또한 스레드를 무한정 생성하면 시스템의 자원이 고갈된다. 이를 해결하기 위해 프로세스를 시작할 때 일정한 수의 스레드를 미리 만들어두고 재사용한다. 이처럼 스레드를 미리 생성하여 보관하는 곳을 스레드 풀이라고 한다.

## CPU 스케줄링
- 멀티 프로그래밍에서 프로세스는 순서대로 CPU에 할당된다. 스케줄링 알고리즘을 통해 최선의 프로세스 순서를 정하는 것이 중요하다.

### 선점 및 비선점 스케줄링
- 실행 중인 프로세스를 빼앗는다면 선점 그렇지 않으면 비선점 스케줄링이다.

### 선입 선처리 스케줄링(First-Come First-Served, FCFS)
- 가장 간단한 알고리즘으로 프로세스가 준비 큐에 먼저 들어오는 순서대로 CPU에 할당된다.
- 하지만 CPU 버스트 길이가 긴 프로세스가 먼저 할당되면, 다른 프로세스들은 긴 시간을 기다려야 한다. 이를 호위 효과(convey effect)라고 한다.

### 최단 작업 우선 스케줄링(Shortest-Job-First, SJF)
 - 실행 시간이 가장 짧은 프로세스가 먼저 실행되는 알고리즘이다.
 - 평균 대기 시간이 최적인 알고리즘이나 CPU 버스트 길이를 정확하게 예측할 수는 없어서 예측 값으로 구현한다.
 - CPU 버스트 길이가 긴 프로세스의 경우 계속 CPU의 할당을 받지 못할 수도 있다. 이를 기아 상태(starvation)라고 한다.

### 라운드 로빈 스케줄링(Round-Robin, RR)
- 일정 시간 동안만 CPU를 사용한 후 준비 큐의 맨 뒤로 이동하는 방식의 알고리즘이다.
- 공평하게 프로세스를 할당할 수 있지만, 각 프로세스에 할당하는 시간을 길게 잡으면 FCFS와 차이가 없게 되고, 짧게 잡으면 컨택스트 스위칭으로 인해 오버헤드가 커진다.

### 우선 순위 스케줄링(Priority Scheduling)
- 각 프로세스를 우선순위에 따라 CPU에 할당한다. SJF 알고리즘은 우선 순위 스케줄링에 해당한다.
- 이 알고리즘 역시 낮은 우선 순위로 인해 기아 상태가 발생할 수 있으므로 노화(aging)를 적용하여 대기 시간이 늘어날수록 우선 순위를 높인다.

## 동기화
- 프로세스나 스레드는 병렬 혹은 병행하여 실행될 때, 특정 자원에 접근 및 실행 결과가 발생한 순서에 영향을 받는 것을 경쟁 상황(race condition)이라고 한다.
- 이런 상황이 발생하면 공유 변수에 예상치 못한 변화가 발생할 수 있고 이를 해결하기 위해 동기화가 필요하다.

### 해결 방법
1. 뮤텍스 락(Mutex Locks)
- 임계 구역에 진입하기 위해서는 반드시 락을 획득하고 빠져나올 때는 락을 반환하여 하나의 프로세스만 임계 구역에 진입하도록 하는 동기화 방법이다.
- 락은 얻고 반환하는 함수는 원자적으로 실행되어야 한다.
- while문을 이용하여 구현할 경우 대기 프로세스는 락을 얻을 때까지 while에 갖혀있어 바쁜 대기(busy wating)를 해야한다. 이 상태를 스핀락(spinlock)이라고 한다. 하지만 컨텍스트 스위칭이 없으므로 임계구역이 짧다면 유용하게 활용할 수 있다.

2. 세마포(Semaphores)
- 임계 구역에 진입할 수 있는 프로세스의 수를 세마포 값으로 정해서 관리할 수 있다.
- 이때 세마포의 값이 0과 1만을 값으로 가질 수 있다면 이진 세마포, 그 외에는 카운팅 세마포라고 하는데 이진 세마포는 뮤텍스 락과 유사하게 동작한다.
- 뮤텍스 락과 마찬가지로 세마포 값을 조작하는 함수는 원자적으로 실행되어야 한다.

3. 모니터(Moniters)
- 뮤텍스 락과 세마포가 동기화를 위해 효과적으로 쓰일 순 있지만, 프로그래머가 잘못된 프로그래밍을 하면 전체 프로세스에 악영향을 줄 수 있다.
- 이를 위해 프로그래밍 언어 수준에서 제공해주는 동기화 도구를 모니터라고하며 대표적으로 java가 있다.



